---
title: 'Flat indices for arrays in R/Rcpp'
author: ''
date: '2022-09-19'
output: md_document
categories: []
tags:
  - Rcpp
featured_image: /post/2022-09-19-flat-indices-for-arrays-in-r-rcpp/flat_array_v2.jpg
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<p>Although <strong>3-dimensional</strong> arrays are not the most common object used among
the R projects, which are dominated by <code>data.frame</code>-like objects. However, when
we’re starting to work with <strong>deep learning</strong>, (e.g. using <a href="https://tensorflow.rstudio.com/reference/keras/"><code>{keras}</code></a>),
we can run into such objects many times, especially in fields like <strong>time series forecasting</strong> or <strong>NLP</strong>.</p>
<p>The question I’d like to answer in this post is how to find ‘flat’ equivalent of the
three-element index for the <strong>3-dimensional</strong> arrays.</p>
<div id="problem" class="section level2">
<h2>Problem</h2>
<p>Let’s create a sample array to present the problem.</p>
<pre class="r"><code>data &lt;- array(0, c(20, 7, 5))</code></pre>
<p>To get the single element, an array can be subscripted in two ways:</p>
<ul>
<li><strong>using indices for all the existing dimensions</strong></li>
</ul>
<pre class="r"><code>data[12, 3, 1] &lt;- 7
data[12, 3, 1]</code></pre>
<pre><code>## [1] 7</code></pre>
<ul>
<li><strong>using a single index</strong></li>
</ul>
<p>In this approach the array is treated as a <strong>flat vector</strong>, so I named this kind of
indexing <strong>flat index</strong>.</p>
<pre class="r"><code>data[123] &lt;- 8
data[123]</code></pre>
<pre><code>## [1] 8</code></pre>
<p><strong>But how we can easily tranform the first type of indexing into the second one?</strong></p>
</div>
<div id="solution" class="section level2">
<h2>Solution</h2>
<p>The solution generalized to the <span class="math inline">\(n\)</span>-dimensional case can be expressed as:</p>
<center>
<span class="math inline">\([x_1, x_2, x_3, ..., x_n] = x_1 + \sum_{i=2}^{n}x_i\prod_{j = 1}^{i-1}d_j\)</span>
</center>
<p>where <span class="math inline">\(x_i\)</span> means i-th index and <span class="math inline">\(d_i\)</span> i-th dimension size. This solution takes into account the 1-based indexing which is used in R.</p>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<p>Suppose we have an array with the same dimesnions as shown above: <span class="math inline">\((20, 7, 5)\)</span>.
We’d like to access an element at index <span class="math inline">\((11, 3, 2)\)</span>.</p>
<pre class="r"><code>example &lt;- array(0, c(20, 7, 5))
example[11, 3, 2] &lt;- 7</code></pre>
<p>We calculate the <em>flat index</em> according to the aforementioned schema.</p>
<pre class="r"><code>flat_idx &lt;- 11 + (3 - 1) * 20 + (2 - 1) * 20 * 7
example[flat_idx]</code></pre>
<pre><code>## [1] 7</code></pre>
</div>
<div id="code-snippets" class="section level2">
<h2>Code snippets</h2>
<p>In R code;</p>
<pre class="r"><code>#&#39; Get an index you can use access an array element at once 
#&#39; [x, y, z] = x + (y - 1) * x_dim + (z - 1) * x_dim * y_dim
#&#39; [x, y] = x + (y-1) * x_dim
#&#39;
#&#39; @param dim_sizes Dimensions sizes
#&#39; @param dim_indices Indices
flat_index &lt;- function(dim_sizes, dim_indices){
  dim_indices[1] + sum((dim_indices[-1] - 1) * cumprod(dim_sizes[-length(dim_sizes)]))
}</code></pre>
<pre class="r"><code># Example 1
arr &lt;- array(0, c(4,5,6,7))
arr[1,2,3,4] &lt;- 777

flat_index(c(4,5,6,7), c(1,2,3,4))</code></pre>
<pre><code>## [1] 405</code></pre>
<pre class="r"><code>which(arr == 777)</code></pre>
<pre><code>## [1] 405</code></pre>
<pre class="r"><code># Example 2
arr2 &lt;- array(0, c(32,10,5))
arr2[12,8,4] &lt;- 777

flat_index( c(32,10,5), c(12,8,4))</code></pre>
<pre><code>## [1] 1196</code></pre>
<pre class="r"><code>which(arr2 == 777)</code></pre>
<pre><code>## [1] 1196</code></pre>
<p>In <strong>Rcpp</strong>, you can use the following code snippet (for 3-dimensional arrays):</p>
<pre class="c"><code>// In C++ transformed to the zero-based index
int flat_index(int dim1, int dim2,
               int idx1, int idx2, int idx3){
  return idx1 + idx2 * dim1 + idx3 * dim1 * dim2;
}</code></pre>
</div>
